{"code":"import * as tslib_1 from \"tslib\";\r\nimport { QueryApi } from '../api';\r\nimport { Deferred } from '../utils/Deferred';\r\nimport { CancellationError, LargeResponseError } from '../utils/errors';\r\nvar EXECUTE_OPTIONS_DEFAULTS = { limitChars: Infinity };\r\nvar CHECK_LIMIT_INTERVAL = 500;\r\nvar default_1 = (function () {\r\n    function default_1(basePath, baseOptions) {\r\n        this.service = new QueryApi({ basePath: basePath, baseOptions: baseOptions });\r\n        this.serviceOptions = baseOptions;\r\n        this.basePath = basePath;\r\n    }\r\n    default_1.prototype.ast = function (query) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var data;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4, this.service.postQueryAst(undefined, undefined, {\r\n                            query: query,\r\n                        }, this.serviceOptions)];\r\n                    case 1:\r\n                        data = (_a.sent()).data;\r\n                        return [2, data.ast];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    default_1.prototype.execute = function (orgID, query, options) {\r\n        if (options === void 0) { options = EXECUTE_OPTIONS_DEFAULTS; }\r\n        var xhr = new XMLHttpRequest();\r\n        var deferred = new Deferred();\r\n        var limitChars = options.limitChars, extern = options.extern;\r\n        var interval;\r\n        var onError = function () {\r\n            clearTimeout(interval);\r\n            var bodyError = null;\r\n            try {\r\n                var body_1 = JSON.parse(xhr.responseText);\r\n                bodyError = body_1.message || body_1.error;\r\n            }\r\n            catch (_a) {\r\n                if (xhr.responseText && xhr.responseText.trim() !== '') {\r\n                    bodyError = xhr.responseText;\r\n                }\r\n            }\r\n            var statusError = xhr.statusText;\r\n            var fallbackError = 'failed to execute Flux query';\r\n            var error = new Error(bodyError || statusError || fallbackError);\r\n            error.name = 'QueryError';\r\n            deferred.reject(error);\r\n        };\r\n        var handleData = function () {\r\n            if (xhr.responseText && xhr.responseText.length > limitChars) {\r\n                xhr.abort();\r\n                deferred.reject(new LargeResponseError());\r\n            }\r\n            else {\r\n                interval = setTimeout(handleData, CHECK_LIMIT_INTERVAL);\r\n            }\r\n        };\r\n        interval = setTimeout(handleData, CHECK_LIMIT_INTERVAL);\r\n        xhr.onload = function () {\r\n            if (xhr.status === 200) {\r\n                clearTimeout(interval);\r\n                deferred.resolve(xhr.responseText);\r\n            }\r\n            else {\r\n                onError();\r\n            }\r\n        };\r\n        xhr.onerror = onError;\r\n        var dialect = { annotations: ['group', 'datatype', 'default'] };\r\n        var body = extern ? { query: query, dialect: dialect, extern: extern } : { query: query, dialect: dialect };\r\n        var url = this.basePath + \"/query?orgID=\" + encodeURIComponent(orgID);\r\n        xhr.open('POST', url);\r\n        xhr.setRequestHeader('Content-Type', 'application/json');\r\n        if (this.serviceOptions && this.serviceOptions.headers) {\r\n            for (var _i = 0, _a = Object.entries(this.serviceOptions.headers); _i < _a.length; _i++) {\r\n                var _b = _a[_i], k = _b[0], v = _b[1];\r\n                xhr.setRequestHeader(k, v);\r\n            }\r\n        }\r\n        xhr.send(JSON.stringify(body));\r\n        return {\r\n            promise: deferred.promise,\r\n            cancel: function () {\r\n                clearTimeout(interval);\r\n                xhr.abort();\r\n                deferred.reject(new CancellationError());\r\n            },\r\n        };\r\n    };\r\n    return default_1;\r\n}());\r\nexport default default_1;\r\n","references":["/Users/denizkusefoglu/go/src/github.com/influxdata/influxdb-client-js/src/api/index.ts","/Users/denizkusefoglu/go/src/github.com/influxdata/influxdb-client-js/src/types/index.ts","/Users/denizkusefoglu/go/src/github.com/influxdata/influxdb-client-js/src/utils/Deferred.ts","/Users/denizkusefoglu/go/src/github.com/influxdata/influxdb-client-js/src/utils/errors.ts"],"dts":{"name":"/Users/denizkusefoglu/go/src/github.com/influxdata/influxdb-client-js/wrappers/queries.d.ts","writeByteOrderMark":false,"text":"import { Package } from '../api';\r\nimport { ServiceOptions, File } from '../types';\r\ninterface ExecuteOptions {\r\n    limitChars: number;\r\n    extern?: File;\r\n}\r\nexport default class {\r\n    private service;\r\n    private serviceOptions;\r\n    private basePath;\r\n    constructor(basePath: string, baseOptions: ServiceOptions);\r\n    ast(query: string): Promise<Package | undefined>;\r\n    execute(orgID: string, query: string, options?: ExecuteOptions): {\r\n        promise: Promise<string>;\r\n        cancel: () => void;\r\n    };\r\n}\r\nexport {};\r\n"}}
